# Задание 1:

# Определяем простую функцию, которая складывает два числа
def add_numbers(x, y):
    return x + y


# Определяем функцию-декоратор, которая добавляет отладочную информацию
def debug_decorator(func):
    def wrapper(*args, **kwargs):
        # Печатаем имя вызываемой функции
        print("Вызов функции:", func.__name__)
        # Печатаем аргументы, переданные функции
        print("Аргументы:", args, kwargs)
        # Вызываем оригинальную функцию с переданными аргументами и сохраняем результат
        result = func(*args, **kwargs)
        # Печатаем результат вызова функции
        print("Результат:", result)
        # Возвращаем результат
        return result
    return wrapper


# Этот декоратор принимает функцию в качестве аргумента и возвращает новую функцию-обертку,
# которая добавляет отладочные сообщения в процесс выполнения исходной функции.
# Чтобы применить этот декоратор к функции add_numbers, мы можем вызвать эту функцию с аргументом:


# Применяем декоратор debug_decorator к функции add_numbers
@debug_decorator
def add_numbers(x, y):
    return x + y


# Вызываем декорированную функцию add_numbers с аргументами 2 и 3
add_numbers(2, 3)

# Внутренняя функция wrapper декоратора обычно ссылается на переменные из внешней функции, что создает замыкание.
# В примере с декоратором debug_decorator функция wrapper ссылается на func,
# которая была определена во внешней функции debug_decorator.
# Это позволяет декоратору использовать и изменять переменные из внешней функции в рамках своей логики работы,
# что делает декораторы более гибкими инструментами.


