# Задание 2:

# Также декораторы могут использовать замыкания, чтобы сохранять состояния между вызовами функции.
# Например, декоратор может создать замыкание, которое сохраняет информацию о том,
# сколько раз функция была вызвана, и возвращать это значение при каждом вызове функции.

# Вот пример декоратора, который использует замыкание, чтобы отслеживать количество вызовов функции:

# Определяем декоратор, который считает количество вызовов функции
def count_calls(func):
    # Инициализируем счетчик вызовов функции
    num_calls = 0

    # Определяем функцию-обертку
    def wrapper(*args, **kwargs):
        nonlocal num_calls  # Указываем, что будем использовать переменную num_calls из объемлющей функции
        num_calls += 1  # Увеличиваем счетчик вызовов
        print(f"Функция была вызвана {num_calls} раз(а)")  # Выводим количество вызовов
        return func(*args, **kwargs)  # Вызываем оригинальную функцию с переданными аргументами и возвращаем результат

    return wrapper  # Возвращаем функцию-обертку


# Применяем декоратор count_calls к функции my_func
@count_calls
def my_func():
    print("Somebody once told me \nThe world is gonna roll me")


# Вызываем декорированную функцию my_func
my_func()  # Первый вызов, счетчик будет равен 1
my_func()  # Второй вызов, счетчик будет равен 2


# В этом примере декоратор count_calls принимает функцию func и возвращает новую функцию wrapper.
# Последняя отслеживает количество вызовов func и выводит сообщение при каждом вызове.
# Затем декоратор применяется к функции my_func.
# Каждый раз, когда my_func вызывается, декоратор увеличивает счетчик вызовов и выводит сообщение.
